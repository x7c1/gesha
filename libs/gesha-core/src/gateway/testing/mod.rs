mod generate_module_file;
pub use generate_module_file::generate_module_file;

use crate::conversions::{ToOpenApi, ToRustType};
use crate::gateway;
use crate::gateway::Error::UnsupportedExampleLocation;
use crate::gateway::{detect_diff, Reader, Writer};
use crate::renderer::Renderer;
use crate::targets::rust_type::Modules;
use openapi_types::v3_0;
use std::borrow::Cow;
use std::fmt::Debug;
use std::marker::PhantomData;
use std::path::PathBuf;

#[derive(Debug)]
pub struct TestCase<A> {
    pub output: PathBuf,
    pub schema: PathBuf,
    pub example: PathBuf,
    pub module_name: String,
    phantom: PhantomData<A>,
}

impl<A> Clone for TestCase<A> {
    fn clone(&self) -> Self {
        Self {
            output: self.output.clone(),
            schema: self.schema.clone(),
            example: self.example.clone(),
            module_name: self.module_name.clone(),
            phantom: Default::default(),
        }
    }
}

impl TestCase<(v3_0::ComponentsObject, Modules)> {
    pub fn from<A>(yaml_names: Vec<A>) -> Vec<Self>
    where
        A: Into<Cow<'static, str>>,
    {
        yaml_names
            .into_iter()
            .map(|x| x.into())
            .map(Self::create)
            .collect()
    }

    pub fn from_path(path: String) -> gateway::Result<Self> {
        let target = "examples/v3.0/components/";
        if path.starts_with(target) {
            Ok(Self::create(path.replace(target, "").into()))
        } else {
            Err(UnsupportedExampleLocation(path))
        }
    }

    fn create(yaml_name: Cow<str>) -> Self {
        let rs_name = yaml_name.replace(".yaml", ".rs");
        TestCase {
            output: format!("output/v3.0/components/{rs_name}").into(),
            schema: format!("examples/v3.0/components/{yaml_name}").into(),
            example: format!("examples/v3.0/components/{rs_name}").into(),
            module_name: yaml_name.replace(".yaml", ""),
            phantom: Default::default(),
        }
    }
}

fn generate_rust_type<A, B>(target: TestCase<(A, B)>) -> gateway::Result<()>
where
    A: Debug + ToOpenApi,
    B: Debug + ToRustType<A> + Renderer,
{
    println!("target> {:#?}", target);

    let reader = Reader::new::<A>();
    let rust_types: B = reader.open_rust_type(target.schema)?;
    println!("rust_types> {:#?}", rust_types);

    let writer = new_writer(target.output);
    writer.create_file(rust_types)
}

pub fn test_rust_type<A, B>(target: TestCase<(A, B)>) -> gateway::Result<()>
where
    A: Debug + ToOpenApi,
    B: Debug + ToRustType<A> + Renderer,
{
    generate_rust_type(target.clone())?;
    detect_diff(&target.output, &target.example)
}

pub fn test_rust_type_to_overwrite<A, B>(target: TestCase<(A, B)>) -> gateway::Result<()>
where
    A: Debug + ToOpenApi,
    B: Debug + ToRustType<A> + Renderer,
{
    generate_rust_type(target.clone())?;

    // example doesn't exist at first attempt.
    // let not_exist = !Path::new(&target.example).exists();
    let not_exist = !target.example.exists();
    if not_exist {
        new_writer(&target.example).touch()?;
    }

    // contrary to test_rust_type(),
    // target.example is actual file, target.output modified is expected file.
    detect_diff(&target.example, &target.output)
}

pub fn new_writer<A: Into<PathBuf>>(path: A) -> Writer {
    Writer {
        path: path.into(),
        preamble: Some("/*\n    Generated by gesha command; DO NOT EDIT BY HAND!\n*/".to_string()),
    }
}
