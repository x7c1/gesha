use crate::v3_0::components::core::CoreShape;
use crate::v3_0::components::request_bodies::RequestBodiesShape;
use crate::v3_0::components::schemas::SchemasShape;
use crate::v3_0::components::ComponentsShape;
use gesha_core::conversions;
use gesha_core::Error::FormatFailed;
use gesha_rust_types::NonDocComments;
use openapi_types::v3_0;
use std::path::Path;
use std::process::Command;

#[derive(Clone, Default)]
pub struct Definition {}

impl conversions::Definition for Definition {
    type OpenApiType = v3_0::ComponentsObject;
    type TargetType = gesha_rust_types::SourceCode;

    fn convert(&self, this: Self::OpenApiType) -> Result<Self::TargetType, conversions::Error> {
        let shapes = ComponentsShape {
            schemas: SchemasShape::shape(this.schemas)?,
            request_bodies: RequestBodiesShape::shape(this.request_bodies)?,
            core: CoreShape::default(),
        };
        let mod_defs = shapes.into_mod_defs()?;
        Ok(new_code().set_mod_defs(mod_defs))
    }

    fn format_code(&self, path: &Path) -> gesha_core::Result<String> {
        let output = Command::new("rustfmt")
            .arg("--verbose")
            .arg(path)
            .output()
            .map_err(|e| FormatFailed {
                path: path.into(),
                detail: format!("{:?}", e),
            })?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(FormatFailed {
                path: path.into(),
                detail: String::from_utf8_lossy(&output.stderr).to_string(),
            })
        }
    }
}

pub(crate) fn new_code() -> gesha_rust_types::SourceCode {
    gesha_rust_types::SourceCode::empty().set_preamble(NonDocComments::block(
        "    Generated by gesha command; DO NOT EDIT BY HAND!",
    ))
}
