use crate::v3_0::components::core::{ComponentsShape, CoreShape};
use crate::v3_0::components::request_bodies::RequestBodiesShape;
use crate::v3_0::components::schemas::SchemasShape;
use crate::v3_0::components::transform;
use gesha_core::Error::FormatFailed;
use gesha_core::conversions;
use gesha_core::conversions::{Output, Result, by_key, with_key};
use gesha_rust_types::NonDocComments;
use openapi_types::v3_0;
use openapi_types::v3_0::ComponentsObject;
use std::path::Path;
use std::process::Command;

#[derive(Clone, Debug, Default)]
pub struct DocumentConverter {}

impl conversions::Converter for DocumentConverter {
    type OpenApiType = v3_0::Document;
    type TargetType = gesha_rust_types::SourceCode;

    fn convert(&self, src: Self::OpenApiType) -> Result<Output<Self::TargetType>> {
        let Some(components) = src.components else {
            // the spec allows empty components
            // see https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#document-structure
            return Ok(Output::ok(gesha_rust_types::SourceCode::empty()));
        };
        let output = generate_components_code(components).bind_errors(with_key("#(convert)"));
        Ok(output)
    }

    fn format_code(&self, path: &Path) -> gesha_core::Result<String> {
        format_code(path)
    }
}

pub(crate) fn new_code() -> gesha_rust_types::SourceCode {
    gesha_rust_types::SourceCode::empty().set_preamble(NonDocComments::block(
        "    Generated by gesha command; DO NOT EDIT BY HAND!",
    ))
}

pub(crate) fn generate_components_code(
    components: ComponentsObject,
) -> Output<gesha_rust_types::SourceCode> {
    let (schemas, errors_of_schemas) = SchemasShape::shape(components.schemas)
        .bind_errors(with_key("schemas"))
        .into_tuple();

    let (request_bodies, errors_of_request_bodies) =
        RequestBodiesShape::shape(components.request_bodies)
            .bind_errors(with_key("request_bodies"))
            .into_tuple();

    let shapes = ComponentsShape {
        schemas,
        request_bodies,
        core: CoreShape::default(),
    };

    let (mod_defs, errors_of_mods) = transform(shapes)
        .map_err(by_key("#(transform)"))
        .map(|shapes| shapes.define().bind_errors(with_key("#(define)")))
        .unwrap_or_else(Output::err)
        .into_tuple();

    let code = new_code().set_mod_defs(mod_defs);
    Output::ok(code)
        .append(errors_of_schemas)
        .append(errors_of_request_bodies)
        .append(errors_of_mods)
        .bind_errors(with_key("components"))
}

pub(crate) fn format_code(path: &Path) -> gesha_core::Result<String> {
    let output = Command::new("rustfmt")
        .arg("--verbose")
        .arg(path)
        .output()
        .map_err(|e| FormatFailed {
            path: path.into(),
            detail: format!("{:?}", e),
        })?;

    if output.status.success() {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Err(FormatFailed {
            path: path.into(),
            detail: String::from_utf8_lossy(&output.stderr).to_string(),
        })
    }
}
